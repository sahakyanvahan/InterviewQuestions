<h1 align="center"> .NET and ASP.NET </h1>
<br/><br/>

## 1. Can you please describe What is .NET. How does it work? 
### Answer
>.NET is a software framework developed by Microsoft. It allows developers to build a wide range of applications, including desktop, web, and mobile, using various programming languages such as C#, F#, and Visual Basic. The framework includes a common runtime environment, a large class library, and a just-in-time (JIT) compiler.

>When a developer writes code using one of the supported languages and runs it on the .NET Framework, the code is first compiled into an intermediate language (IL) code. This IL code is then executed by the runtime environment, which converts it into machine code using the JIT compiler. This process, known as just-in-time (JIT) compilation, ensures that the code is optimized for the specific machine on which it is running.

>The .NET Framework also includes a large class library, which provides a wide range of pre-written code for common tasks such as file input/output, network communication, and data access. This allows developers to write less code and focus more on the unique aspects of their applications.

>In summary, .NET Framework is a software development platform which provides a runtime environment, a large class library and a JIT compiler to develop, run and execute the applications. Developers can use different languages to write the code for the application and the framework will take care of the rest.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ----****----                |                 |
---
<br/><br/>

## 2. Can you please name languages that .NET supports? 
### Answer
>C#, F#, VB, Iron Python, Iron Ruby C++ etc. 

---

## 3. Can you please tell what is JIT? 
### Answer
>A just-in-time (JIT) compiler is a type of compiler that compiles code at runtime, as opposed to ahead-of-time (AOT) compilers that compile code before the program is executed.

>In the case of the .NET Framework, the JIT compiler is a part of the runtime environment. When an application written in a .NET-compatible language is executed, the JIT compiler takes the intermediate language (IL) code generated by the compiler and compiles it into machine code that can be executed by the host machine's CPU. This process is known as just-in-time (JIT) compilation.

>JIT compilation has several advantages over AOT compilation. Because the code is compiled at runtime, the JIT compiler can take into account the specific characteristics of the host machine, such as the CPU architecture, and optimize the code accordingly. This can result in faster execution times and better performance. Additionally, JIT compilation allows for more efficient memory usage, as the compiled code is only kept in memory for as long as it is needed.

>JIT compilation also allows for dynamic code generation, which enables features such as dynamic method invocation and reflection. It also allows for the ability to update the application without having to recompile the entire application.

>In summary, JIT compiler is a type of compiler that compiles the code at runtime and it is a part of the runtime environment of the .NET Framework. The JIT compiler takes the IL code and converts it into machine code that can be executed by the host machine's CPU. This provides several advantages like faster execution time, better performance, efficient memory usage, and support for dynamic code generation, reflection, and updates.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ----****----                |                 |
---
<br/><br/>

## 4. Can you please describe what is .NET CLR  
### Answer
>The CLR is the runtime environment of the .NET framework and is responsible for executing code, managing memory, handling exceptions, and providing security.
>.NET CLR (Common Language Runtime) is the virtual machine component of Microsoft's .NET framework. It is responsible for managing the execution of .NET applications and providing services such as memory management, security, and exception handling.

>When a .NET program is executed, the CLR converts the program's code (written in languages such as C# or Visual Basic) into machine code that can be executed by the computer's processor. This process is known as just-in-time (JIT) compilation. The CLR also manages the program's memory and ensures that it is used efficiently. Additionally, the CLR provides a number of services to the program, such as security, threading, and exception handling.

>In summary, .NET CLR is responsible for executing the .NET application by compiling and managing the program's memory and providing services for security, threading, and exception handling.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ----****----                |                 |
---
<br/><br/>

## 5. What is garbage collector: How it works. How many generations objects have. How to use it
### Answer
>The garbage collector (GC) is a component of the .NET CLR that automatically manages the memory used by a .NET program. It helps to ensure that the program does not run out of memory by periodically freeing up memory that is no longer being used by the program.

>The GC works by periodically scanning the program's memory and identifying objects that are no longer being used by the program. These objects are then marked for collection and are subsequently removed from memory during the next garbage collection cycle.

>The GC uses a concept of generations to organize objects in memory. Objects are divided into three generations: Generation 0, Generation 1, and Generation 2.

>Generation 0 is the youngest generation and is used to store newly created objects. These objects are typically short-lived and are quickly collected during a garbage collection cycle.

>Generation 1 is used to store objects that have survived one or more garbage collection cycles. These objects are typically longer-lived and are collected less frequently than objects in Generation 0.

>Generation 2 is the oldest generation and is used to store objects that have survived many garbage collection cycles. These objects are typically the longest-lived and are collected infrequently.

>You don't need to use garbage collector specifically, it runs automatically in the background, it is responsible for cleaning up memory that is no longer being used by your program. However, you can use the GC class in the System namespace to force a garbage collection at a specific point in your code if you need to.

>In summary, Garbage collector is a component of .NET CLR, which automatically manages memory used by a program. It periodically scans memory, identifies and marks objects that are no longer in use, and frees up memory for the program to use. The GC uses a concept of generations to organize objects in memory, and you don't need to use it specifically, as it runs automatically. However, you can force a garbage collection at a specific point in your code if you need to.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ----****----                |                 |
---
<br/><br/>

## 2. What is .net assembly and what are the main components of assembly And what are the types of assembly
### *Answer*

>.NET assembly is a fundamental unit of deployment, versioning, and security in the .NET framework. It is a collection of one or more files that are used to build and run applications and libraries in the .NET environment.

>The main components of an assembly are:

* Metadata: This contains information about the assembly, such as the types, methods, and fields defined in the assembly, as well as information about the assembly's dependencies.

* MSIL (Microsoft Intermediate Language): This is the machine-independent code that is generated by the compiler. This code is then Just-In-Time (JIT) compiled to machine code when the assembly is loaded and executed.

* Resources: These can include files such as images, audio files, or localized strings that are included with the assembly.

* Assembly manifest: This contains information about the assembly, including its version number, culture, and strong name. It also describes the assembly's dependencies on other assemblies and the permissions required to run the assembly.

> Assemblies can be either a single file or a multi-file assembly, which contains more than one file. A single file assembly contains both the assembly manifest and the MSIL code in a single file with the extension .dll or .exe. A multi-file assembly contains the assembly manifest in a separate file with the extension .manifest, and the MSIL code in one or more files with the extension .dll or .exe.

> In the .NET framework, there are two types of assemblies: private assemblies and shared assemblies.

* Private assemblies: These are assemblies that are intended to be used by a single application, and they are typically located in the application's local folder. They are not intended to be shared by multiple applications.

* Shared assemblies: These are assemblies that are intended to be used by multiple applications. They are typically installed in the global assembly cache (GAC), which is a special folder where shared assemblies are stored. They are also typically given a strong name, which is a unique name that includes a public key and a digital signature. This allows for versioning and ensures that different versions of the same assembly can coexist on the same system.

> Additionally, there are also satellite assemblies, which are assemblies that contain resources for a specific language or culture. They are used to provide localized resources for an application, such as translated strings or images. Satellite assemblies are typically deployed in the same directory as the main assembly, and they have a specific naming convention, such as "MyAssembly.resources.dll"

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ----****----                |                 |
---
<br/><br/>

# 3. Can you explain the difference between the managed and unmanaged code in the .NET framework?
## Answer
> Managed code is code that runs within the CLR and is managed by the CLR's memory manager, while unmanaged code is code that runs outside of the CLR and is not managed by the CLR's memory manager. Examples of unmanaged code in the .NET framework include C/C++ code that is called via P/Invoke.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ----****----                |                 |
---
<br/><br/>

## 7. Please describe service lifetimes for dependency injection in ASP.NET Core  
### Answer
>In ASP.NET Core, dependency injection (DI) is used to manage the lifetime of services, which are objects that are created to perform a specific task or set of tasks. There are several different service lifetimes that can be used in ASP.NET Core, including:

>Transient: A new instance of the service is created each time it is requested. This lifetime is appropriate for services that do not maintain state or have a very short lifespan.

>Scoped: A new instance of the service is created for each request, but the same instance is used for all requests within the same scope. This lifetime is appropriate for services that maintain state and need to be created and disposed of on a per-request basis.

>Singleton: A single instance of the service is created and shared by all requests. This lifetime is appropriate for services that are long-lived and do not maintain state.

>Instance: An instance of the service is provided explicitly and the DI container will not dispose it. This lifetime is appropriate for service that you want to manage the lifetime, for example, when you want to dispose them when you are done using them.

>You can set the lifetime of a service by using the appropriate method of the IServiceCollection interface when adding the service to the DI container. For example, to add a service with a transient lifetime, you would use the AddTransient method:
```C#
services.AddTransient<MyService>();
```
You can also set the lifetime of a service using attributes, for example [Transient] or [Scoped]
```C#
[Transient]
public class MyService { }
```
>In summary, the service lifetimes in ASP.NET Core determine how long a service is kept in memory, and how many instances of the service are created. There are 4 types of service lifetimes: Transient, Scoped, Singleton, and Instance. You can set the lifetime of a service by using the appropriate method of the IServiceCollection interface when adding the service to the DI container, or by using attributes.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ----****----                |                 |
---
<br/><br/>

## 8. Please describe the difference between eager loading and lazy loading in EF core.  
### Answer
>In Entity Framework Core (EF Core), eager loading and lazy loading are techniques used to load related data when querying a database.

>Eager loading is a technique where related data is loaded along with the main data in a single query. This is done by using the `Include` method on a query to specify the related data that should be loaded. For example, the following query uses eager loading to load all related orders when querying for customers:

``` C#
var customers = context.Customers
            .Include(c => c.Orders)
            .ToList();
```
>In contrast, lazy loading is a technique where related data is not loaded until it is specifically accessed. This is done by marking navigation properties with the `virtual` keyword. When a navigation property is accessed, EF Core will automatically generate a query to load the related data. For example, the following code uses lazy loading to load the related orders when a customer is accessed:

``` C#
var customer = context.Customers.FirstOrDefault();
var orders = customer.Orders;
```

>Lazy loading is enabled by default in EF Core but you can disable it by setting the `UseLazyLoadingProxies` to false in the DbContext options when creating the context.

>Eager loading can be more efficient when you know that you will need the related data and you want to load it all in one query, whereas lazy loading can be more efficient when you only need the related data occasionally and you want to avoid loading it until it is needed.

>In summary, the main difference between eager loading and lazy loading in EF Core is when the related data is loaded: Eager loading loads the related data along with the main data in a single query, while lazy loading loads the related data only when it is specifically accessed. Eager loading can be more efficient when you know that you will need the related data and you want to load it all in one query, whereas lazy loading can be more efficient when you only need the related data occasionally and you want to avoid loading it until it is needed.


| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ----****----                |                 |
---
<br/><br/>

## 9. What is LINQ  
### Answer
> Is a set of technologies built in C# that enables to manipulate with sets of data  
>LINQ (Language Integrated Query) is a set of features in C# and Visual Basic that provides a consistent and expressive syntax for querying and manipulating data in various data sources, including in-memory data structures, databases, and XML documents.

>LINQ allows developers to write queries in a declarative way, using a syntax that is similar to SQL. This makes it easier for developers to work with data, regardless of its origin or format, and reduces the amount of code that needs to be written to perform common data operations such as filtering, sorting, and grouping.

>For example, the following LINQ query retrieves all customers whose names start with "A":

```C#
var customers = from c in context.Customers
                where c.Name.StartsWith("A")
                select c;
```

>LINQ also includes a set of standard query operators that can be used to perform a wide range of data operations, such as filtering, sorting, and grouping. These operators can be used to perform queries on in-memory data structures, such as lists and arrays, as well as on data sources that implement the IQueryable interface, such as databases and XML documents.

>LINQ can also be used to query data in non-relational data sources. For example, LINQ to XML provides an easy way to query and manipulate XML data in C# and Visual Basic.

>In summary, LINQ is a set of features in C# and Visual Basic that provides a consistent and expressive syntax for querying and manipulating data in various data sources. It allows developers to write queries in a declarative way, using a syntax that is similar to SQL, and it reduces the amount of code that needs to be written to perform common data operations. LINQ also includes a set of standard query operators that can be used to perform a wide range of data operations on in-memory data structures, as well as on data sources that implement the IQueryable interface, such as databases and XML documents.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ----****----                |                 |
---
<br/><br/>

## 10. What is the difference between IQueryable and IEnumerable 
### Answer
> The difference between IQueryable and IEnumerable is about where the filter logic is executed. One executes on the client side and the other executes on the database (In reality answer is more complicated, but this part is enough) 

>IQueryable and IEnumerable are both interfaces in C# that define methods for working with collections of data. The main difference between the two is that IQueryable allows for the creation of LINQ queries that can be executed against a database, while IEnumerable is used for in-memory collections and the queries are executed locally.

>IEnumerable is best used when working with small amounts of data that can be easily loaded into memory. It's useful for simple queries and operations that can be performed in a single pass.

>IQueryable, on the other hand, is more powerful and is best used when working with large amounts of data that can't be loaded into memory all at once. It allows for the creation of complex, multi-step queries that are executed in a more efficient manner.

>In short, IEnumerable is for in-memory collection and IQueryable is for database querying.


| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ----****----                |                 |
---
<br/><br/>

## 11. What is the difference between NUnit and XUnit 
### Answer
> One of the main differences is the syntax for writing tests. NUnit uses a more traditional, attribute-based syntax for marking test methods, while xUnit uses a more fluent, method-based syntax. For example, in NUnit, a test method is marked with the [Test] attribute, while in xUnit, it is marked with the [Fact] attribute.

>Another difference is that xUnit is designed to be more extensible and modular than NUnit. xUnit uses a more composable architecture, which allows developers to create their own custom test runners, test discoverers, and other components.

>Another difference is the way how they handle test discovery and execution. NUnit loads all the tests in an assembly at once and then runs them, xUnit uses a more dynamic approach, it only loads the tests that are going to be executed, this could be an advantage when dealing with large test suites.

>Additionally, xUnit has some features that are not present in NUnit. For example, xUnit has built-in support for test theories (tests that are parameterized with multiple sets of data) and collection fixtures (shared context for tests in a test collection).

> NUnit creates an instance of test class for each method while XUnit creates one instance of a class for all methods in that class 

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ----****----                |                 |
---
<br/><br/>

## 12. How to test private methods 
### Answer
> There is no way to test private methods. They are implementation details 


| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ----****----                |                 |
---
<br/><br/>

## 14. What is middleware 
### Answer
>
| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ----****----                |                 |
---
<br/><br/>
