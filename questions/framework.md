<h1 align="center"> .NET and ASP.NET </h1>
<br/><br/>

## 1. Can you please describe What is .NET. How does it work? 
### Answer
>.NET is a software framework developed by Microsoft. It allows developers to build a wide range of applications, including desktop, web, and mobile, using various programming languages such as `C#`, `F#`, and `Visual Basic`. The framework includes a common runtime environment, a large class library, and a just-in-time (JIT) compiler.

>When a developer writes code using one of the supported languages and runs it on the .NET Framework, the code is first compiled into an intermediate language (IL) code. This IL code is then executed by the runtime environment, which converts it into machine code using the JIT compiler. This process, known as just-in-time (JIT) compilation, ensures that the code is optimized for the specific machine on which it is running.

>The .NET Framework also includes a large class library, which provides a wide range of pre-written code for common tasks such as file input/output, network communication, and data access. This allows developers to write less code and focus more on the unique aspects of their applications.

>In summary, .NET Framework is a software development platform which provides a runtime environment, a large class library and a JIT compiler to develop, run and execute the applications. Developers can use different languages to write the code for the application and the framework will take care of the rest.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | General Desciptions         |                 |
| **L2**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
---
<br/><br/>

## 2. Can you please name languages that .NET supports? 
### Answer
>C#, F#, VB, Iron Python, Iron Ruby C++ etc. 

---

## 3. Can you please describe what is .NET CLR?
### Answer
>The CLR is the runtime environment of the .NET framework and is responsible for executing code, managing memory, handling exceptions, and providing security.
    
>.NET CLR (Common Language Runtime) is the virtual machine component of Microsoft's .NET framework. It is responsible for managing the execution of .NET applications and providing services such as memory management, security, and exception handling.

>When a .NET program is executed, the CLR converts the program's code (written in languages such as C# or Visual Basic) into machine code that can be executed by the computer's processor. This process is known as just-in-time (JIT) compilation. The CLR also manages the program's memory and ensures that it is used efficiently. Additionally, the CLR provides a number of services to the program, such as security, threading, and exception handling.

>In summary, .NET CLR is responsible for executing the .NET application by compiling and managing the program's memory and providing services for security, threading, and exception handling.

>The main parts of the .NET Common Language Runtime (CLR) are the following:

* The Just-In-Time (JIT) compiler, which converts Intermediate Language (IL) code into native machine code at runtime.

* The Common Type System (CTS), which defines how data types are declared, used, and managed in the runtime.

* The Common Language Specification (CLS), which defines a set of rules for language interoperability within the .NET Framework.

* The Garbage Collector, which automatically manages the allocation and release of memory for objects.

* The Class Loader, which is responsible for loading and initializing types at runtime.

* The Security Manager, which enforces security policies and grants permissions to assemblies.

* The Execution Engine, which is responsible for executing the JIT-compiled code and providing services such as exception handling and thread management.

* The Base Class Library (BCL) which is a library of classes, interfaces, and value types that are included with the .NET Framework and provide a wide range of functionality for various areas such as data access, file I/O, networking, and more.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | General Desciptions         |                 |
| **L2**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               | Mentions main parts of .NET CLR |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               | ↑↑↑↑↑↑↑↑↑↑↑↑↑   |
---
<br/><br/>

## 4. Can you please tell what is JIT? 
### Answer
>A just-in-time (JIT) compiler is a type of compiler that compiles code at runtime, as opposed to ahead-of-time (AOT) compilers that compile code before the program is executed.

>In the case of the .NET Framework, the JIT compiler is a part of the runtime environment. When an application written in a .NET-compatible language is executed, the JIT compiler takes the intermediate language (IL) code generated by the compiler and compiles it into machine code that can be executed by the host machine's CPU. This process is known as just-in-time (JIT) compilation.

>JIT compilation has several advantages over AOT compilation. Because the code is compiled at runtime, the JIT compiler can take into account the specific characteristics of the host machine, such as the CPU architecture, and optimize the code accordingly. This can result in faster execution times and better performance. Additionally, JIT compilation allows for more efficient memory usage, as the compiled code is only kept in memory for as long as it is needed.

>JIT compilation also allows for dynamic code generation, which enables features such as dynamic method invocation and reflection. It also allows for the ability to update the application without having to recompile the entire application.

>In summary, JIT compiler is a type of compiler that compiles the code at runtime and it is a part of the runtime environment of the .NET Framework. The JIT compiler takes the IL code and converts it into machine code that can be executed by the host machine's CPU. This provides several advantages like faster execution time, better performance, efficient memory usage, and support for dynamic code generation, reflection, and updates.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | General Desciptions         |                 |
| **L2**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
---
<br/><br/>

## 5. What is garbage collector? How it works? How many generations objects have? How to use it?
### Answer
>The garbage collector (GC) is a component of the .NET CLR that automatically manages the memory used by a .NET program. It helps to ensure that the program does not run out of memory by periodically freeing up memory that is no longer being used by the program.

>The GC works by periodically scanning the program's memory and identifying objects that are no longer being used by the program. These objects are then marked for collection and are subsequently removed from memory during the next garbage collection cycle.

>The GC uses a concept of generations to organize objects in memory. Objects are divided into three generations: Generation 0, Generation 1, and Generation 2.

>**Generation 0** is the youngest generation and is used to store newly created objects. These objects are typically short-lived and are quickly collected during a garbage collection cycle.

>**Generation 1** is used to store objects that have survived one or more garbage collection cycles. These objects are typically longer-lived and are collected less frequently than objects in Generation 0.

>**Generation 2** is the oldest generation and is used to store objects that have survived many garbage collection cycles. These objects are typically the longest-lived and are collected infrequently.

>You don't need to use garbage collector specifically, it runs automatically in the background, it is responsible for cleaning up memory that is no longer being used by your program. However, you can use the `GC` class in the `System` namespace to force a garbage collection at a specific point in your code if you need to.

>In summary, Garbage collector is a component of .NET CLR, which automatically manages memory used by a program. It periodically scans memory, identifies and marks objects that are no longer in use, and frees up memory for the program to use. The GC uses a concept of generations to organize objects in memory, and you don't need to use it specifically, as it runs automatically. However, you can force a garbage collection at a specific point in your code if you need to.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | General Desciptions         |                 |
| **L2**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               | Mentions about GC.Collect, Finalize, which is protected and should be overriden and SuppressFinalize and Dispose |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               | Mentions about generations  |
---
<br/><br/>

## 6. What is .NET assembly and what are the main components of assembly And what are the types of assembly?
### *Answer*

>.NET assembly is a fundamental unit of deployment, versioning, and security in the .NET framework. It is a collection of one or more files that are used to build and run applications and libraries in the .NET environment.

>The main components of an assembly are:

* **Metadata**: This contains information about the assembly, such as the types, methods, name, version number, and culture and fields defined in the assembly, as well as information about the assembly's dependencies.

* **MSIL (Microsoft Intermediate Language)**: This is the machine-independent code that is generated by the compiler. This code is then Just-In-Time (JIT) compiled to machine code when the assembly is loaded and executed.

* **Resources**: These can include files such as images, audio files, or localized strings that are included with the assembly.

* **Assembly manifest**: This contains information about the assembly, including its version number, culture, and strong name. It also describes the assembly's dependencies on other assemblies and the permissions required to run the assembly.

>Assemblies can be either a single file or a multi-file assembly, which contains more than one file. A single file assembly contains both the assembly manifest and the MSIL code in a single file with the extension .dll or .exe. A multi-file assembly contains the assembly manifest in a separate file with the extension .manifest, and the MSIL code in one or more files with the extension .dll or .exe.

>In the .NET framework, there are two types of assemblies: private assemblies and shared assemblies.

* **Private assemblies**: These are assemblies that are intended to be used by a single application, and they are typically located in the application's local folder. They are not intended to be shared by multiple applications.

* **Shared assemblies**: These are assemblies that are intended to be used by multiple applications. They are typically installed in the global assembly cache (GAC), which is a special folder where shared assemblies are stored. They are also typically given a strong name, which is a unique name that includes a public key and a digital signature. This allows for versioning and ensures that different versions of the same assembly can coexist on the same system.

>Additionally, there are also satellite assemblies, which are assemblies that contain resources for a specific language or culture. They are used to provide localized resources for an application, such as translated strings or images. Satellite assemblies are typically deployed in the same directory as the main assembly, and they have a specific naming convention, such as "MyAssembly.resources.dll"

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | General Description         |                 |
| **L2**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               | Should mention some parts of assembly |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               | Should mention all parts of assembly |
---
<br/><br/>

# 7. Can you explain the difference between the managed and unmanaged code in the .NET framework?
## Answer
> Managed code is code that runs within the CLR and is managed by the CLR's memory manager, while unmanaged code is code that runs outside of the CLR and is not managed by the CLR's memory manager. Examples of unmanaged code in the .NET framework include C/C++ code that is called via P/Invoke.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Not sure what it i          |                 |
| **L3**    | Right answer                |                 |
---
<br/><br/>

## 8. Please describe the difference between eager loading and lazy loading in EF core.  
### Answer
>In Entity Framework Core (EF Core), eager loading and lazy loading are techniques used to load related data when querying a database.

>Eager loading is a technique where related data is loaded along with the main data in a single query. This is done by using the `Include` method on a query to specify the related data that should be loaded. For example, the following query uses eager loading to load all related orders when querying for customers:
``` C#
var customers = context.Customers
            .Include(c => c.Orders)
            .ToList();
```
>In contrast, lazy loading is a technique where related data is not loaded until it is specifically accessed. This is done by marking navigation properties with the `virtual` keyword. When a navigation property is accessed, EF Core will automatically generate a query to load the related data. For example, the following code uses lazy loading to load the related orders when a customer is accessed:
``` C#
var customer = context.Customers.FirstOrDefault();
var orders = customer.Orders;
```

>Lazy loading is enabled by default in EF Core but you can disable it by setting the `UseLazyLoadingProxies` to false in the DbContext options when creating the context.

>Eager loading can be more efficient when you know that you will need the related data and you want to load it all in one query, whereas lazy loading can be more efficient when you only need the related data occasionally and you want to avoid loading it until it is needed.

>In summary, the main difference between eager loading and lazy loading in EF Core is when the related data is loaded: Eager loading loads the related data along with the main data in a single query, while lazy loading loads the related data only when it is specifically accessed. Eager loading can be more efficient when you know that you will need the related data and you want to load it all in one query, whereas lazy loading can be more efficient when you only need the related data occasionally and you want to avoid loading it until it is needed.


| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer or not sure       |                 |
| **L2**    | General describtion         |                 |
| **L3**    | Detailed describtion        | Mentions `virtual ` keyword in navigation properties |
---
<br/><br/>

## 9. What is LINQ  
### Answer 
>LINQ (Language Integrated Query) is a set of features in C# and Visual Basic that provides a consistent and expressive syntax for querying and manipulating data in various data sources, including in-memory data structures, databases, and XML documents.

>LINQ allows developers to write queries in a declarative way, using a syntax that is similar to SQL. This makes it easier for developers to work with data, regardless of its origin or format, and reduces the amount of code that needs to be written to perform common data operations such as filtering, sorting, and grouping.

>For example, the following LINQ query retrieves all customers whose names start with "A":
```C#
var customers = from c in context.Customers
                where c.Name.StartsWith("A")
                select c;
```
>LINQ also includes a set of standard query operators that can be used to perform a wide range of data operations, such as filtering, sorting, and grouping. These operators can be used to perform queries on in-memory data structures, such as lists and arrays, as well as on data sources that implement the `IQueryable` interface, such as databases and XML documents.

>LINQ can also be used to query data in non-relational data sources. For example, LINQ to XML provides an easy way to query and manipulate XML data in C# and Visual Basic.

>In summary, LINQ is a set of features in C# and Visual Basic that provides a consistent and expressive syntax for querying and manipulating data in various data sources. It allows developers to write queries in a declarative way, using a syntax that is similar to SQL, and it reduces the amount of code that needs to be written to perform common data operations. LINQ also includes a set of standard query operators that can be used to perform a wide range of data operations on in-memory data structures, as well as on data sources that implement the IQueryable interface, such as databases and XML documents.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | General Desciptions         |                 |
| **L2**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
---
<br/><br/>

## 10. Are you familiar with `AsNoTracking` extension method?
### Answer 
>

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | General Desciptions         |                 |
| **L2**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
---
<br/><br/>

## 11. What is the difference between `First()` and `FirstOrDefault()`? 
### Answer 
>`First()` method will throw an `InvalidOperationException` if the sequence is empty. It is used when you expect the sequence to always contain an element and want to immediately raise an error if it doesn't.

>`FirstOrDefault()` method will return a default value for the type of elements in the sequence if the sequence is empty. The default value for value types is 0 for numeric types and false for bool, and for reference types it is null. This method is used when the sequence might be empty and you want to handle this case gracefully, without raising an error.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | General Desciptions         |                 |
| **L2**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
---
<br/><br/>

## 12. What is the difference between IQueryable and IEnumerable 
### Answer
>IQueryable and IEnumerable are both interfaces in C# that define methods for working with collections of data. The main difference between the two is that IQueryable allows for the creation of LINQ queries that can be executed against a database, while IEnumerable is used for in-memory collections and the queries are executed locally.

>IEnumerable is best used when working with small amounts of data that can be easily loaded into memory. It's useful for simple queries and operations that can be performed in a single pass.

>IQueryable, on the other hand, is more powerful and is best used when working with large amounts of data that can't be loaded into memory all at once. It allows for the creation of complex, multi-step queries that are executed in a more efficient manner.

>In short, IEnumerable is for in-memory collection and IQueryable is for database querying.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | Don't know                  |                 |
| **L2**    | General Desciptions         |                 |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
---
<br/><br/>

## 12. Are you familiar with code first migrations? Please describe them
### Answer
>Code First Migrations is a feature in Entity Framework (EF) that allows you to manage changes to your database schema over time, as your application evolves. With Code First Migrations, you can define your database schema using C# classes, and then use EF to automatically generate and apply changes to the database as needed.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | Don't know                  |                 |
| **L2**    | General Desciptions         |                 |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
---
<br/><br/>

## 13. Are you familiar with FIRST principles of Unit testing?
### Answer
>The FIRST principles of unit testing are a set of guidelines that can help you write high-quality, effective unit tests. The acronym "FIRST" stands for:

> * **Fast:** Unit tests should be fast and run quickly, allowing you to run them frequently as part of your development process.
> * **Independent:** Unit tests should be isolated from each other, with no dependencies on the results of other tests. This ensures that tests can be run in any order, and that the failure of one test does not affect the outcome of other tests.
> * **Repeatable:** Unit tests should produce the same results every time they are run, regardless of the environment or state of the system.
> * **Self-Validating:** Unit tests should have clear and verifiable outcomes, making it easy to determine whether the test has passed or failed.
> * **Timely:** Unit tests should be written and run in a timely manner, as close as possible to the development of the corresponding code. This helps to catch errors early in the development process, when they are easier and less expensive to fix.

>By following the FIRST principles, you can write unit tests that are efficient, reliable, and effective in detecting errors in your code. This can help you to maintain a high-quality codebase, reduce the risk of bugs and regression, and improve your overall development process.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | Don't know                  |                 |
| **L2**    | General Desciptions         |                 |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
---
<br/><br/>

## 14. Do you know what is testing pyramid?
### Answer
>The testing pyramid is a visual representation of the different types of tests that should be used in software development and the relative proportion of each type. It is called a "pyramid" because the tests are arranged in layers, with more tests at the bottom (unit tests) and fewer tests at the top (end-to-end tests).

>The testing pyramid consists of the following types of tests:

> * **Unit Tests:** These are the most numerous tests, and they test individual components or functions in isolation. They are fast, automated, and reliable, and they are used to validate the basic functionality of the code.

> * **Integration Tests:** These tests test the interactions between different components, to ensure that they work together as expected. They are still automated, but they take longer to run and are more complex than unit tests.

> * **End-to-End Tests:** These tests test the entire system, from end-to-end, to ensure that everything works as expected. They are slower, more complex, and more brittle than the other types of tests, and they are used to validate the overall functionality of the system.

>The goal of the testing pyramid is to provide a balance between the different types of tests, so that you can validate the functionality of the system with a minimum of tests, while still covering all the important aspects of the system. By following the testing pyramid, you can ensure that your tests are fast, reliable, and effective, and that you are not spending too much time on slow and complex tests that add little value.

>It's worth noting that the testing pyramid is a guideline, not a strict rule, and there may be cases where you need to deviate from the pyramid, depending on the specific requirements of your project. However, in general, following the testing pyramid can help you to write effective and efficient tests for your software.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | Don't know                  |                 |
| **L2**    | General Desciptions         |                 |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
---
<br/><br/>

## 15. What is the difference between NUnit and XUnit 
### Answer
>One of the main differences is the syntax for writing tests. NUnit uses a more traditional, attribute-based syntax for marking test methods, while xUnit uses a more fluent, method-based syntax. For example, in NUnit, a test method is marked with the [Test] attribute, while in xUnit, it is marked with the [Fact] attribute.

>Another difference is that xUnit is designed to be more extensible and modular than NUnit. xUnit uses a more composable architecture, which allows developers to create their own custom test runners, test discoverers, and other components.

>Another difference is the way how they handle test discovery and execution. NUnit loads all the tests in an assembly at once and then runs them, xUnit uses a more dynamic approach, it only loads the tests that are going to be executed, this could be an advantage when dealing with large test suites.

>Additionally, xUnit has some features that are not present in NUnit. For example, xUnit has built-in support for test theories (tests that are parameterized with multiple sets of data) and collection fixtures (shared context for tests in a test collection).

>NUnit creates an instance of test class for each method while XUnit creates one instance of a class for all methods in that class 

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | General Answer              | Mentions last point |
| **L3**    | General Answer              | Mentions other points as well |
---
<br/><br/>

## 16. What is TDD? Pros and Cons. 
### Answer
> Test-Driven Development (TDD) is a software development methodology where the development of software is done through a repeated process of writing test cases before writing the code and then writing just enough code to pass the tests. The cycle of writing tests, writing code, and refactoring the code continues until the software meets all the requirements.
> 
> ### **Pros:**
> * **Improved code quality:** By writing tests first, developers can ensure that the code meets the requirements and works as intended.
> * **Early detection of bugs:** Tests help to catch bugs early in the development process, making it easier and quicker to fix them.
> * **Better design:** The process of writing tests can help to reveal design flaws and improve the overall design of the code.
> * **Increased confidence:** With a comprehensive suite of tests, developers can feel confident in making changes to the code without introducing new bugs.

> ### **Cons:**
> * **Time-consuming:** Writing tests takes time, which can be a drawback, especially in fast-paced development environments.
> * **Overhead:** The process of TDD can add an additional layer of complexity to the development process.
> * **Resistance to change:** TDD requires a change in mindset and approach to software development, which can be difficult for some developers to adopt.

> ### **Best practices:**
> * **Write tests first:** Always write tests before writing the code, to ensure that the code meets the requirements and works as intended.
> * **Keep tests simple:** Tests should be simple, focused, and fast. Avoid complex test setups and keep tests independent of each other.
> * **Automate tests:** Automate as many tests as possible to save time and ensure consistency.
> * **Refactor code regularly:** Regularly refactor code to keep it clean and maintainable.
> * **Prioritize tests:** Prioritize tests based on the criticality of the code. Write tests for the most critical parts of the code first.
> * **Write meaningful test names:** Test names should clearly describe what the test is doing, making it easier to understand the intent of the test

>The "Red-Green-Refactor" approach is a common practice in Test-Driven Development (TDD). It involves writing a failing test first, and then writing the minimum amount of code necessary to make the test pass. Finally, you refactor the code to make it clean, maintainable, and efficient.

>Here's how the "Red-Green-Refactor" approach works in detail:

> * **Red:** Write a failing test case for the new functionality you want to add. The test should express the desired behavior of the code, and should initially fail because the functionality hasn't been implemented yet.

> * **Green:** Write the minimum amount of code necessary to make the test pass. This should be the bare minimum implementation, with no frills or unnecessary complexity.

> * **Refactor:** Once the test is passing, clean up the code, making it readable, maintainable, and efficient. You can also add additional tests if necessary to ensure the code works as expected.

>This approach helps you focus on writing code that works, and not just code that compiles. It also helps you ensure that your code is well-designed, readable, and maintainable, as you are forced to think about the design and implementation of the code before writing it.

>In TDD, the "Red-Green-Refactor" approach is repeated for each new feature or change you want to make to the code. This results in a suite of tests that provide a safety net for your code, making it easier to catch and fix bugs, and ensuring that new changes don't break existing functionality.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
---
<br/><br/>

## 17. How to test private methods 
### Answer

>The best practice for testing private methods in C# is to focus on testing the public API of a class, and not rely on the implementation details of private methods. This results in a cleaner design, better code maintainability, and more robust tests.

> * **Reflection:** You can use the Reflection API to access private methods and invoke them. Reflection allows you to dynamically inspect and interact with types and members of an assembly, including private methods.
>
> With `PrivateObject`, you can access and invoke private methods, properties, and fields of a class. It is especially useful when you need to test code that has tight coupling between the implementation and the private methods.
>Here's an example of how to use `PrivateObject` to test a private method:

``` C#
using Microsoft.VisualStudio.TestTools.UnitTesting;

[TestClass]
public class MyClassTests
{
    [TestMethod]
    public void TestPrivateMethod()
    {
        var myClass = new MyClass();
        var privateObject = new PrivateObject(myClass);

        int result = (int)privateObject.Invoke("PrivateMethod", 42);

        Assert.AreEqual(84, result);
    }
}
```

>In this example, we create an instance of the `PrivateObject` class, passing in an instance of the `MyClass` class. Then, we use the `Invoke` method of the `PrivateObject` class to access and invoke the private method `PrivateMethod`, passing in an argument of 42. Finally, we use an `Assert` statement to verify that the result of the invocation is 84.

>It's important to note that relying on `PrivateObject` to test private members of a class goes against the principles of unit testing, as it tightly couples the tests to the implementation details of the class. It's better to refactor the code and test the public API of the class instead, whenever possible.

| **Level** | **Expectaions**             | **Notes**       |
|-----------|-----------------------------|-----------------|
| **L1**    | No Answer                   |                 |
| **L2**    | Right Answer                |                 |
| **L3**    | ↑↑↑↑↑↑↑↑↑↑↑↑↑               |                 |
---
<br/><br/>